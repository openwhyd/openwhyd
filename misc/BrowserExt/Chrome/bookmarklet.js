/***********************************************/
/* Automatically generated from bookmarklet.ts */
/*       DO NOT EDIT THIS FILE MANUALLY        */
/***********************************************/
(() => {
  // Track detectors
  // TODO: refactor makeFileDetector() and makeStreamDetector() to pass element param before callback
  function makeFileDetector() {
    const eidSet = {}; // to prevent duplicates // TODO: is this still useful, now that we de-duplicate in toDetect ?
    return function detectMusicFiles(url, cb, element) {
      const [fileName, ext] = url.split(/[/.]/).slice(-2);
      if (ext !== 'mp3' && ext !== 'ogg') return cb();
      if (eidSet[url] || !fileName) return cb();
      const getNodeText = (node) =>
        (node.innerText || node.textContent || '').trim().split('\n')[0]; // keep just the first line of text (useful for suggested YouTube links that include stats on following lines)
      // TODO: also use node.title and node.alt, like in makeFileDetector() and DetectEmbed() ?
      const title =
        (element ? element.title || getNodeText(element) : null) ||
        decodeURIComponent(fileName);
      eidSet[url] = true;
      cb({
        id: url,
        title: title.replace(/^\s+|\s+$/g, ''),
        img: '/images/cover-audiofile.png',
      });
    };
  }
  // players = { playerId -> { getEid(), fetchMetadata() } }
  // returns detectPlayableStreams(url, callback, element)
  function makeStreamDetector(players) {
    const eidSet = {}; // to prevent duplicates // TODO: is this still useful, now that we de-duplicate in toDetect ?
    function getPlayerId(url) {
      for (const i in players) {
        const player = players[i];
        const eId = player.getEid(url);
        if (eId) return i;
      }
    }
    // an urlDetector must callback with a track Object (with fields: {id, eId, title, img}) as parameter, if detected
    return function detectPlayableStreams(url, cb, element = {}) {
      // 1. find the matching player and track identifier
      const playerId = getPlayerId(url);
      const player = playerId && players[playerId];
      const trackId =
        player === null || player === void 0 ? void 0 : player.getEid(url);
      const eid = trackId && `/${playerId}/${trackId.replace(/^\//, '')}`; // TODO: get rid of the removal of leading slash character, after fixing playem's soundcloud.getEid()
      if (!eid || eidSet[eid]) return cb();
      // 2. extract the (optional) stream URL from the identifier
      const parts = eid.split('#');
      const streamUrl = parts[1] && /^https?:\/\//.test(parts[1]);
      if (eidSet[parts[0]] && !streamUrl) return cb(); // i.e. store if new, overwrite if new occurence contains a streamUrl
      // 3. store the identifier, with and without stream URL, to prevent duplicates
      eidSet[parts[0]] = true;
      eidSet[eid] = true;
      const detectedTrack = {
        eId: eid,
        sourceId: playerId,
        sourceLabel: player.label,
      };
      if (element.artist && element.title) {
        return cb(
          Object.assign(Object.assign({}, detectedTrack), {
            title: `${element.artist} - ${element.title}`,
            img: element.img,
          }),
        );
      }
      if (!player.fetchMetadata) {
        return cb(detectedTrack); // quit if we can't enrich the metadata
      }
      // 4. try to return the track with enriched metadata
      player.fetchMetadata(url, function (track) {
        if (!track || !Object.keys(track).length) return cb(detectedTrack);
        cb(
          Object.assign(
            Object.assign(Object.assign({}, detectedTrack), track),
            {
              title: track.title || element.name,
              eId: track.eId || eid.substr(0, 4) + track.id,
            },
          ),
        );
      });
    };
  }
  if (typeof exports !== 'undefined') {
    exports.makeFileDetector = makeFileDetector;
    exports.makeStreamDetector = makeStreamDetector;
  }
  // Each detector is called once per web page and returns a list of Query, DomElement and/or Track objects.
  const openwhydBkPageDetectors = [
    function detectYouTubePageTrack(window) {
      if (/ - YouTube$/.test(window.document.title) === false) return null;
      const videoElement =
        window.document.getElementsByTagName('ytd-watch-flexy')[0];
      if (!videoElement) return null;
      const videoId = videoElement.getAttribute('video-id');
      if (!videoId || window.location.href.indexOf(videoId) == -1) return null;
      return [
        {
          id: videoId,
          src: window.location.href,
          name: window.document.title.replace(/ - YouTube$/, ''),
        },
      ];
    },
    function detectPandoraTrack(window) {
      const { host } = window.location;
      if (host !== 'pandora.com' && host !== 'www.pandora.com') return null;
      const getNodeText = (node) =>
        (node.innerText || node.textContent || '').trim().split('\n')[0]; // keep just the first line of text (useful for suggested YouTube links that include stats on following lines)
      // TODO: also use node.title and node.alt, like in makeFileDetector() and DetectEmbed() ?
      const artist = getNodeText(
          window.document.getElementsByClassName('playerBarArtist')[0] || {},
        ),
        title = getNodeText(
          window.document.getElementsByClassName('playerBarSong')[0] || {},
        );
      return artist && title
        ? [{ src: window.location.href, searchQuery: artist + ' - ' + title }]
        : [];
    },
    function detectDeezerTrack(window) {
      const dzTrackId = window.dzPlayer && window.dzPlayer.getSongId();
      return dzTrackId
        ? [{ src: 'https://www.deezer.com/track/' + dzTrackId }]
        : [];
    },
    function detectTrackFromTitle(window) {
      const title = window.document.title
        .replace(/[▶<>"']+/g, ' ')
        .replace(/[ ]+/g, ' ');
      const titleParts = [
        ' - Spotify',
        ' | www.deezer.com',
        ' - Xbox Music',
        ' - Royalty Free Music - Jamendo',
      ];
      for (let i = 0; i < titleParts.length; ++i)
        if (title.indexOf(titleParts[i]) > -1)
          return [
            {
              src: window.location.href,
              searchQuery: title.replace(titleParts[i], ''),
            },
          ];
    },
    function extractBandcampTracks(window) {
      let toDetect = [];
      const bc = window.TralbumData;
      if (bc) {
        const bcPrefix = '/bc/' + bc.url.split('//')[1].split('.')[0] + '/';
        toDetect = bc.trackinfo.map(function (tr) {
          if (tr.file) {
            const streamUrl = tr.file[Object.keys(tr.file)[0]];
            return {
              href: streamUrl,
              eId: bcPrefix + tr.title_link.split('/').pop() + '#' + streamUrl,
              name: bc.artist + ' - ' + tr.title,
              img: bc.art_id
                ? `https://f4.bcbits.com/img/a${bc.art_id}_16.jpg`
                : undefined,
              artist: bc.artist,
              title: tr.title,
            };
          }
        });
        if (toDetect.length) return toDetect;
      }
      // list Bandcamp track URLs
      const bandcampPageUrlEl =
        window.document.querySelector &&
        window.document.querySelector('meta[property="og:url"]');
      if (!bandcampPageUrlEl) return [];
      let bandcampPageUrl = bandcampPageUrlEl.getAttribute('content');
      if (bandcampPageUrl.indexOf('bandcamp.com/track/') != -1)
        toDetect.push({ src: bandcampPageUrl });
      else {
        const pathPos = bandcampPageUrl.indexOf('/', 10);
        if (pathPos != -1) bandcampPageUrl = bandcampPageUrl.substr(0, pathPos); // remove path
        const elts = window.document.querySelectorAll('a[href^="/track/"]');
        for (let j = 0; j < elts.length; ++j)
          toDetect.push({
            href: bandcampPageUrl + elts[j].getAttribute('href'),
          });
      }
      return toDetect;
      // TODO: window.document.querySelectorAll('script[title*="bandcamp.com/download/track"]') // only works on track and album pages
    },
    function parseDomElements(window) {
      let results = [];
      ['iframe', 'object', 'embed', 'a', 'audio', 'source'].forEach(
        function (elName) {
          results = results.concat(
            Array.prototype.slice.call(
              window.document.getElementsByTagName(elName),
            ),
          );
        },
      );
      return results;
    },
  ];
  if (typeof exports !== 'undefined') {
    exports.pageDetectors = openwhydBkPageDetectors;
  }
  const openwhydYouTubeExtractor = {
    getEid: function (url) {
      // code imported from playem-all
      if (
        /(youtube\.com\/(v\/|embed\/|(?:.+)?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]+)/.test(
          url,
        ) ||
        /^\/yt\/([a-zA-Z0-9_-]+)/.test(url) ||
        /youtube\.com\/attribution_link\?.*v%3D([^ %]+)/.test(url) ||
        /youtube.googleapis.com\/v\/([a-zA-Z0-9_-]+)/.test(url)
      )
        return RegExp['$+']; //.lastParen;
    },
    fetchMetadata: function (url, callback) {
      const id = this.getEid(url);
      callback({
        id: id,
        eId: '/yt/' + id,
        img: 'https://i.ytimg.com/vi/' + id + '/default.jpg',
        url: 'https://www.youtube.com/watch?v=' + id,
        playerLabel: 'Youtube',
      });
    },
  };
  if (typeof exports !== 'undefined') {
    exports.openwhydYouTubeExtractor = openwhydYouTubeExtractor;
  }
  function makeBookmarklet({ pageDetectors }) {
    let detectedTracks = 0;
    // Helpers
    function getNodeText(node) {
      return (node.innerText || node.textContent || '').trim().split('\n')[0]; // keep just the first line of text (useful for suggested YouTube links that include stats on following lines)
      // TODO: also use node.title and node.alt, like in makeFileDetector() and DetectEmbed() ?
    }
    function unwrapFacebookLink(src) {
      // e.g. http://www.facebook.com/l.php?u=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DKhXn0anD1lE&h=AAQFjMJBoAQFTPOP4HzFCv0agQUHB6Un31ArdmwvxzZxofA
      let fbLink =
        src && typeof src.split === 'function'
          ? src.split('facebook.com/l.php?u=')
          : [];
      if (fbLink.length > 1) {
        fbLink = decodeURIComponent(fbLink.pop().split('&').shift());
        const result =
          new URL(fbLink).host !== 'www.facebook.com' ? fbLink : src;
        return result;
      }
      return src;
    }
    function detectTracks({ window, ui, urlDetectors, urlPrefix }) {
      // an urlDetector must callback with a track Object (with fields: {id, eId, title, img}) as parameter, if detected
      // TODO: decouple from ui <= let caller provide one handler to be called for each detected track
      function detectTrack(url, element, cb) {
        const remainingUrlDetectors = urlDetectors.slice();
        (function processNext() {
          if (!remainingUrlDetectors.length) return cb();
          const trackDetector = remainingUrlDetectors.shift();
          trackDetector(
            url,
            function (track) {
              if (track) cb(track);
              // Note: previously, the condition above was track && track.id, for some reason 🤷‍♂️
              else processNext();
            },
            element,
          );
        })();
      }
      function detectEmbed(element, cb) {
        const url =
          element.eId ||
          unwrapFacebookLink(element.href || element.src || element.data || '');
        if (!url) return cb();
        detectTrack(url, element, function (track) {
          if (track) {
            track.url = url;
            track.title =
              track.title ||
              getNodeText(element) ||
              element.title ||
              element.alt; // || track.eId || url || p.label;
            if (track.sourceLabel)
              track.sourceLogo =
                urlPrefix +
                '/images/icon-' +
                track.sourceLabel.split(' ')[0].toLowerCase() +
                '.png';
          }
          cb(track);
        });
      }
      function whenDone(searchThumbs) {
        searchThumbs.forEach(function (searchThumb) {
          detectedTracks++;
          ui.addSearchThumb(searchThumb);
        });
        console.info('finished detecting tracks!');
        if (detectedTracks === 0) {
          detectedTracks++;
          ui.addSearchThumb({ searchQuery: window.document.title });
        }
        ui.finish();
      }
      const toDetect = new (function ElementStack() {
        // this class holds a collections of elements that potentially reference streamable tracks
        const set = {};
        function normalize(url) {
          if (typeof url === 'string' && !/^javascript:/.test(url)) {
            return url.split('#')[0];
          } else {
            return undefined;
          }
        }
        function size(elt) {
          return (elt.name || getNodeText(elt) || '').length;
        }
        this.has = function (url) {
          const normalized = normalize(url);
          return normalized && !!set[normalized];
        };
        this.push = function (elt) {
          const url =
            elt &&
            normalize(
              elt.eId ||
                unwrapFacebookLink(elt.href || elt.src || elt.data || ''),
            );
          if (!url) return;
          const existingElt = set[url];
          if (!existingElt || size(elt) > size(existingElt)) {
            set[url] = elt;
          }
        };
        this.getSortedArray = function () {
          const eIds = [],
            urls = [],
            keys = Object.keys(set);
          for (let i = 0; i < keys.length; ++i)
            (/\/..\//.test(keys[i]) ? eIds : urls).push(set[keys[i]]);
          return eIds.concat(urls);
        };
      })();
      console.info('1/2 parse page...');
      pageDetectors.map(function (detectFct) {
        const results = detectFct(window) || [];
        console.info('-----' + detectFct.name, '=>', results.length);
        results.map(function (result) {
          toDetect.push(result);
        });
      });
      if (!toDetect.has(window.location.href))
        toDetect.push({
          src: window.location.href,
          searchQuery: window.document.title,
        });
      console.info('2/2 list streamable tracks...');
      const eltArray = toDetect.getSortedArray();
      const searchThumbs = [];
      (function processNext() {
        const elt = eltArray.shift();
        if (!elt) whenDone(searchThumbs);
        else
          detectEmbed(elt, function (track) {
            if (track) {
              detectedTracks++;
              if (track.img && track.img[0] === '/') {
                track.img = urlPrefix + track.img;
              }
              ui.addThumb(track);
            } else searchThumbs.push(elt);
            processNext();
          });
      })();
    }
    return {
      detectTracks,
    };
  }
  if (typeof exports !== 'undefined') {
    exports.makeBookmarklet = makeBookmarklet;
  }
  if (typeof exports === 'undefined') {
    // running from web browser only, not from Node.js
    (window._initWhydBk = function () {
      // prevents bug in firefox 3
      if (undefined == window.console)
        window.console = Object.assign(Object.assign({}, window.console), {
          log: function () {} /* eslint-disable-line @typescript-eslint/no-empty-function */,
          info: function () {} /* eslint-disable-line @typescript-eslint/no-empty-function */,
          error:
            function () {} /* eslint-disable-line @typescript-eslint/no-empty-function */,
          warn: function () {} /* eslint-disable-line @typescript-eslint/no-empty-function */,
        });
      console.log('-= openwhyd bookmarklet v2.23 =-');
      const FILENAME = '/js/bookmarklet.js';
      const CSS_FILEPATH = '/css/bookmarklet.css';
      // close the bookmarklet by pressing ESC
      window.onkeydownBackup =
        window.onkeydownBackup || window.document.onkeydown;
      const overflowBackup = window.document.body.style.overflow;
      window.document.body.style.overflow = 'hidden';
      window.closeWhydBk = function () {
        window.document.body.removeChild(
          window.document.getElementById('whydBookmarklet'),
        );
        window.document.onkeydown = window.onkeydownBackup;
        window.document.body.style.overflow = overflowBackup;
        delete window.onkeydownBackup;
        delete window.closeWhydBk;
      };
      window.document.onkeydown = (event) => {
        if (event.key === 'Esc') window.closeWhydBk();
      };
      // utility functions
      function findScriptHost(scriptPathName) {
        // TODO: use window.document.currentScript.src when IE becomes completely forgotten by humans
        const els = window.document.getElementsByTagName('script');
        for (let i = els.length - 1; i > -1; --i) {
          const whydPathPos = els[i].src.indexOf(scriptPathName);
          if (whydPathPos > -1) return els[i].src.substr(0, whydPathPos);
        }
      }
      function getSelText() {
        if (window.getSelection) {
          return window.getSelection();
        } else if (window.document.getSelection) {
          return window.document.getSelection();
        } else if (window.document.selection) {
          return window.document.selection.createRange().text;
        }
      }
      function include(src, cb) {
        let inc, timer;
        if (src.split(/[#?]/)[0].split('.').pop().toLowerCase() == 'css') {
          inc = window.document.createElement('link');
          inc.rel = 'stylesheet';
          inc.type = 'text/css';
          inc.media = 'screen';
          inc.href = src;
        } else {
          inc = window.document.createElement('script');
          inc.onload = function () {
            timer = timer ? clearInterval(timer) : null;
            cb && cb();
          };
          const check = () => {
            if (
              inc.readyState &&
              (inc.readyState == 'loaded' ||
                inc.readyState == 'complete' ||
                inc.readyState == 4)
            )
              inc.onload();
          };
          timer = cb ? setInterval(check, 500) : undefined;
          inc.onreadystatechange = check;
          inc.type = 'text/javascript';
          inc.src = src;
        }
        window.document.getElementsByTagName('head')[0].appendChild(inc);
      }
      function imageToHD(track) {
        if (track.img) {
          if (track.eId.substr(1, 2) == 'yt') {
            const img =
              'https://img.youtube.com/vi/' +
              track.eId.substr(4).split('?')[0] +
              '/hqdefault.jpg';
            const i = new Image();
            i.onload = function () {
              if (i.height >= 120) {
                const oldImage = window.document.getElementById(track.id);
                if (oldImage)
                  oldImage.style.backgroundImage = 'url(' + img + ')';
                else
                  console.warn('failed to improve quality of thumb', {
                    track,
                    elementToReplace: oldImage,
                    newImgUrl: img,
                  });
              }
            };
            i.src = img;
          } else if (track.eId.substr(1, 2) == 'sc')
            track.img = track.img.replace('-large', '-t300x300');
          else if (track.eId.indexOf('/dz/') == 0)
            track.img = track.img.replace(/\/image$/, '/image?size=480x640');
          else if (track.eId.indexOf('/ja/') == 0)
            track.img = track.img.replace(
              /\/covers\/1\.200\.jpg$/,
              '/covers/1.600.jpg',
            );
        }
        return track;
      }
      // user interface
      function BkUi() {
        this.nbTracks = 0;
        let div = window.document.getElementById('whydBookmarklet');
        if (!div) {
          window.document.body.appendChild(
            window.document.createElement('div'),
          ).id = 'whydBookmarklet';
          div = window.document.getElementById('whydBookmarklet');
        }
        div.innerHTML = [
          '<div id="whydOverlay"></div>',
          '<div id="whydHeader">',
          '<a target="_blank" href="' +
            urlPrefix +
            '"><img src="' +
            urlPrefix +
            '/images/logo-s.png"></a>',
          '<div onclick="closeWhydBk();" style="background-image:url(' +
            urlPrefix +
            '/images/bookmarklet_ic_close_Normal.png)"></div>',
          '</div>',
          '<div id="whydContent">',
          '<div id="whydLoading"></div>',
          '</div>',
        ].join('\n');
        function showForm(thumb) {
          const text = getSelText();
          const href =
            urlPrefix +
            '/post?v=2&' +
            'embed=' +
            (thumb.eId
              ? '1&eId=' + encodeURIComponent(thumb.eId)
              : encodeURIComponent(thumb.url)) +
            (thumb.title ? '&title=' + encodeURIComponent(thumb.title) : '') +
            '&refUrl=' +
            encodeURIComponent(window.location.href) +
            '&refTtl=' +
            encodeURIComponent(window.document.title) +
            (text ? '&text=' + encodeURIComponent(text) : '');
          const whydPop = window.open(
            href,
            'whydPop',
            'height=460,width=780,location=no,menubar=no,resizable=no,scrollbars=no,toolbar=no',
          );
          whydPop.focus();
          window.closeWhydBk();
        }
        function showSearch(searchQuery) {
          const whydPop = window.open(
            urlPrefix + '/search?q=' + encodeURIComponent(searchQuery),
            'whydSearch',
          );
          whydPop.focus();
          window.closeWhydBk();
        }
        function elt(attrs, children = []) {
          const div = window.document.createElement(attrs.tagName || 'div');
          if (attrs.tagName) delete attrs.tagName;
          if (attrs.img) {
            div.style.backgroundImage = 'url(' + attrs.img + ')';
            delete attrs.img;
          }
          for (const a in attrs) div.setAttribute(a, attrs[a]);
          for (let i = 0; i < (children || []).length; ++i)
            div.appendChild(children[i]);
          return div;
        }
        function selectThumb(e) {
          const tpn = this.parentNode;
          const selected = tpn.className.indexOf(' selected') > -1;
          tpn.className =
            tpn.className.replace(' selected', '') +
            (selected ? '' : ' selected');
          e.preventDefault();
        }
        function renderThumb(thumb) {
          const addBtn = elt({ class: 'whydCont' }, [
            elt({ class: 'whydContOvr' }),
            elt({
              class: 'whydAdd',
              img: urlPrefix + '/images/bookmarklet_ic_add_normal.png',
            }),
          ]);
          addBtn.onclick = thumb.onclick;
          const checkBox = elt({ class: 'whydSelect' }); //onclick: "var tpn=this.parentNode;tpn.className=tpn.className.replace(' selected','')+(tpn.className.indexOf(' selected')>-1?'':' selected');e.preventDefault();"
          checkBox.onclick = selectThumb;
          return elt(
            {
              id: thumb.id,
              class: 'whydThumb',
              'data-eid': thumb.eId,
              img: thumb.img || urlPrefix + '/images/cover-track.png',
            },
            [
              elt({ class: 'whydGrad' }),
              elt({ tagName: 'p' }, [document.createTextNode(thumb.title)]),
              elt({ class: 'whydSrcLogo', img: thumb.sourceLogo }),
              addBtn,
              checkBox,
            ],
          );
        }
        const contentDiv = window.document.getElementById('whydContent');
        this.addThumb = function (thumb) {
          thumb.id = 'whydThumb' + this.nbTracks++;
          thumb = imageToHD(thumb);
          thumb.onclick = thumb.onclick || (() => showForm(thumb));
          contentDiv.appendChild(renderThumb(thumb));
        };
        this.addSearchThumb = function (track) {
          const searchQuery = track.searchQuery || track.name || track.title;
          this.addThumb({
            title: searchQuery || 'Search Openwhyd',
            sourceLogo: urlPrefix + '/images/icon-search-from-bk.png',
            onclick: () => showSearch(searchQuery),
          });
        };
        this.finish = function () {
          window.document.getElementById('whydLoading').style.display = 'none';
        };
        return this;
      }
      // Start up
      const urlPrefix = findScriptHost(FILENAME) || 'https://openwhyd.org',
        urlSuffix = '?' + new Date().getTime();
      console.info('loading bookmarklet stylesheet...');
      include(urlPrefix + CSS_FILEPATH + urlSuffix);
      const extractors = {
        yt: openwhydYouTubeExtractor,
        // sc: new window.SoundCloudPlayer({}), // TODO: implement extractor that doesn't require Playem
        // vi: new window.VimeoPlayer({}), // TODO: implement extractor that doesn't require Playem
        // dm: new window.DailymotionPlayer({}), // TODO: implement extractor that doesn't require Playem
        // dz: new window.DeezerPlayer({}), // TODO: implement extractor that doesn't require Playem
        // bc: new window.BandcampPlayer({}), // TODO: implement extractor that doesn't require Playem
        // ja: new window.JamendoPlayer({}), // TODO: implement extractor that doesn't require Playem
      };
      const bookmarklet = makeBookmarklet({
        pageDetectors: openwhydBkPageDetectors, // defined in bookmarkletPageDetectors.ts
      });
      bookmarklet.detectTracks({
        window,
        ui: BkUi(),
        urlDetectors: [makeFileDetector(), makeStreamDetector(extractors)],
        urlPrefix,
      });
    })();
  }
})();
